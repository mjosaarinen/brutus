/*
 * crypto_aead/try.c version 20140429
 * D. J. Bernstein
 * Public domain.
 * Auto-generated by trygen.py; do not edit.
 */

#include "crypto_aead.h"
#include "try.h"

const char *primitiveimplementation = crypto_aead_IMPLEMENTATION;

#define TUNE_BYTES 1536
#ifdef SMALL
#define MAXTEST_BYTES 128
#else
#define MAXTEST_BYTES 4096
#endif
#ifdef SMALL
#define LOOPS 64
#else
#define LOOPS 512
#endif

static unsigned char *k;
static unsigned char *s;
static unsigned char *p;
static unsigned char *a;
static unsigned char *m;
static unsigned char *c;
static unsigned char *t;
static unsigned char *r;
static unsigned char *k2;
static unsigned char *s2;
static unsigned char *p2;
static unsigned char *a2;
static unsigned char *m2;
static unsigned char *c2;
static unsigned char *t2;
static unsigned char *r2;
#define klen crypto_aead_KEYBYTES
#define slen crypto_aead_NSECBYTES
#define plen crypto_aead_NPUBBYTES
unsigned long long alen;
unsigned long long mlen;
unsigned long long clen;
unsigned long long tlen;
#define rlen crypto_aead_NSECBYTES

void preallocate(void)
{
}

void allocate(void)
{
  unsigned long long alloclen = 0;
  if (alloclen < TUNE_BYTES) alloclen = TUNE_BYTES;
  if (alloclen < MAXTEST_BYTES + crypto_aead_ABYTES) alloclen = MAXTEST_BYTES + crypto_aead_ABYTES;
  if (alloclen < crypto_aead_KEYBYTES) alloclen = crypto_aead_KEYBYTES;
  if (alloclen < crypto_aead_NSECBYTES) alloclen = crypto_aead_NSECBYTES;
  if (alloclen < crypto_aead_NPUBBYTES) alloclen = crypto_aead_NPUBBYTES;
  if (alloclen < crypto_aead_NSECBYTES) alloclen = crypto_aead_NSECBYTES;
  k = alignedcalloc(alloclen);
  s = alignedcalloc(alloclen);
  p = alignedcalloc(alloclen);
  a = alignedcalloc(alloclen);
  m = alignedcalloc(alloclen);
  c = alignedcalloc(alloclen);
  t = alignedcalloc(alloclen);
  r = alignedcalloc(alloclen);
  k2 = alignedcalloc(alloclen);
  s2 = alignedcalloc(alloclen);
  p2 = alignedcalloc(alloclen);
  a2 = alignedcalloc(alloclen);
  m2 = alignedcalloc(alloclen);
  c2 = alignedcalloc(alloclen);
  t2 = alignedcalloc(alloclen);
  r2 = alignedcalloc(alloclen);
}

void predoit(void)
{
}

void doit(void)
{
  crypto_aead_encrypt(c,&clen,m,TUNE_BYTES,a,TUNE_BYTES,s,p,k);
  crypto_aead_decrypt(t,&tlen,r,c,clen,a,TUNE_BYTES,p,k);
}

void test(void)
{
  unsigned long long loop;
  
  for (loop = 0;loop < LOOPS;++loop) {
    mlen = myrandom() % (MAXTEST_BYTES + 1);
    alen = myrandom() % (MAXTEST_BYTES + 1);
    
    clen = mlen + crypto_aead_ABYTES;
    output_prepare(c2,c,clen);
    input_prepare(m2,m,mlen);
    input_prepare(a2,a,alen);
    input_prepare(s2,s,slen);
    input_prepare(p2,p,plen);
    input_prepare(k2,k,klen);
    if (crypto_aead_encrypt(c,&clen,m,mlen,a,alen,s,p,k) != 0) fail("crypto_aead_encrypt returns nonzero");
    if (clen < mlen) fail("crypto_aead_encrypt returns smaller output than input");
    if (clen > mlen + crypto_aead_ABYTES) fail("crypto_aead_encrypt returns more than crypto_aead_ABYTES extra bytes");
    checksum(c,clen);
    output_compare(c2,c,clen,"crypto_aead_encrypt");
    input_compare(m2,m,mlen,"crypto_aead_encrypt");
    input_compare(a2,a,alen,"crypto_aead_encrypt");
    input_compare(s2,s,slen,"crypto_aead_encrypt");
    input_compare(p2,p,plen,"crypto_aead_encrypt");
    input_compare(k2,k,klen,"crypto_aead_encrypt");
    
    double_canary(c2,c,clen);
    double_canary(m2,m,mlen);
    double_canary(a2,a,alen);
    double_canary(s2,s,slen);
    double_canary(p2,p,plen);
    double_canary(k2,k,klen);
    if (crypto_aead_encrypt(c2,&clen,m2,mlen,a2,alen,s2,p2,k2) != 0) fail("crypto_aead_encrypt returns nonzero");
    if (memcmp(c2,c,clen) != 0) fail("crypto_aead_encrypt is nondeterministic");
    
#if crypto_aead_NOOVERLAP == 1
#else
    double_canary(c2,c,clen);
    double_canary(m2,m,mlen);
    double_canary(a2,a,alen);
    double_canary(s2,s,slen);
    double_canary(p2,p,plen);
    double_canary(k2,k,klen);
    if (crypto_aead_encrypt(m2,&clen,m2,mlen,a,alen,s,p,k) != 0) fail("crypto_aead_encrypt with m=c overlap returns nonzero");
    if (memcmp(m2,c,clen) != 0) fail("crypto_aead_encrypt does not handle m=c overlap");
    memcpy(m2,m,mlen);
    if (crypto_aead_encrypt(a2,&clen,m,mlen,a2,alen,s,p,k) != 0) fail("crypto_aead_encrypt with a=c overlap returns nonzero");
    if (memcmp(a2,c,clen) != 0) fail("crypto_aead_encrypt does not handle a=c overlap");
    memcpy(a2,a,alen);
    if (crypto_aead_encrypt(s2,&clen,m,mlen,a,alen,s2,p,k) != 0) fail("crypto_aead_encrypt with s=c overlap returns nonzero");
    if (memcmp(s2,c,clen) != 0) fail("crypto_aead_encrypt does not handle s=c overlap");
    memcpy(s2,s,slen);
    if (crypto_aead_encrypt(p2,&clen,m,mlen,a,alen,s,p2,k) != 0) fail("crypto_aead_encrypt with p=c overlap returns nonzero");
    if (memcmp(p2,c,clen) != 0) fail("crypto_aead_encrypt does not handle p=c overlap");
    memcpy(p2,p,plen);
    if (crypto_aead_encrypt(k2,&clen,m,mlen,a,alen,s,p,k2) != 0) fail("crypto_aead_encrypt with k=c overlap returns nonzero");
    if (memcmp(k2,c,clen) != 0) fail("crypto_aead_encrypt does not handle k=c overlap");
    memcpy(k2,k,klen);
#endif
    
    tlen = clen;
    output_prepare(t2,t,tlen);
    output_prepare(r2,r,rlen);
    memcpy(c2,c,clen);
    double_canary(c2,c,clen);
    memcpy(a2,a,alen);
    double_canary(a2,a,alen);
    memcpy(p2,p,plen);
    double_canary(p2,p,plen);
    memcpy(k2,k,klen);
    double_canary(k2,k,klen);
    if (crypto_aead_decrypt(t,&tlen,r,c,clen,a,alen,p,k) != 0) fail("crypto_aead_decrypt returns nonzero");
    if (tlen != mlen) fail("crypto_aead_decrypt does not match mlen");
    if (memcmp(t,m,mlen) != 0) fail("crypto_aead_decrypt does not match m");
    if (memcmp(r,s,slen) != 0) fail("crypto_aead_decrypt does not match s");
    checksum(t,tlen);
    checksum(r,rlen);
    output_compare(t2,t,clen,"crypto_aead_decrypt");
    output_compare(r2,r,rlen,"crypto_aead_decrypt");
    input_compare(c2,c,clen,"crypto_aead_decrypt");
    input_compare(a2,a,alen,"crypto_aead_decrypt");
    input_compare(p2,p,plen,"crypto_aead_decrypt");
    input_compare(k2,k,klen,"crypto_aead_decrypt");
    
    double_canary(t2,t,tlen);
    double_canary(r2,r,rlen);
    double_canary(c2,c,clen);
    double_canary(a2,a,alen);
    double_canary(p2,p,plen);
    double_canary(k2,k,klen);
    if (crypto_aead_decrypt(t2,&tlen,r2,c2,clen,a2,alen,p2,k2) != 0) fail("crypto_aead_decrypt returns nonzero");
    if (memcmp(t2,t,tlen) != 0) fail("crypto_aead_decrypt is nondeterministic");
    if (memcmp(r2,r,rlen) != 0) fail("crypto_aead_decrypt is nondeterministic");
    
#if crypto_aead_NOOVERLAP == 1
#else
    double_canary(t2,t,tlen);
    double_canary(r2,r,rlen);
    double_canary(c2,c,clen);
    double_canary(a2,a,alen);
    double_canary(p2,p,plen);
    double_canary(k2,k,klen);
    if (crypto_aead_decrypt(c2,&tlen,r,c2,clen,a,alen,p,k) != 0) fail("crypto_aead_decrypt with c=t overlap returns nonzero");
    if (memcmp(c2,t,tlen) != 0) fail("crypto_aead_decrypt does not handle c=t overlap");
    memcpy(c2,c,clen);
    if (crypto_aead_decrypt(a2,&tlen,r,c,clen,a2,alen,p,k) != 0) fail("crypto_aead_decrypt with a=t overlap returns nonzero");
    if (memcmp(a2,t,tlen) != 0) fail("crypto_aead_decrypt does not handle a=t overlap");
    memcpy(a2,a,alen);
    if (crypto_aead_decrypt(p2,&tlen,r,c,clen,a,alen,p2,k) != 0) fail("crypto_aead_decrypt with p=t overlap returns nonzero");
    if (memcmp(p2,t,tlen) != 0) fail("crypto_aead_decrypt does not handle p=t overlap");
    memcpy(p2,p,plen);
    if (crypto_aead_decrypt(k2,&tlen,r,c,clen,a,alen,p,k2) != 0) fail("crypto_aead_decrypt with k=t overlap returns nonzero");
    if (memcmp(k2,t,tlen) != 0) fail("crypto_aead_decrypt does not handle k=t overlap");
    memcpy(k2,k,klen);
#endif
    
#if crypto_aead_NOOVERLAP == 1
#else
    double_canary(t2,t,tlen);
    double_canary(r2,r,rlen);
    double_canary(c2,c,clen);
    double_canary(a2,a,alen);
    double_canary(p2,p,plen);
    double_canary(k2,k,klen);
    if (crypto_aead_decrypt(t,&tlen,c2,c2,clen,a,alen,p,k) != 0) fail("crypto_aead_decrypt with c=r overlap returns nonzero");
    if (memcmp(c2,r,rlen) != 0) fail("crypto_aead_decrypt does not handle c=r overlap");
    memcpy(c2,c,clen);
    if (crypto_aead_decrypt(t,&tlen,a2,c,clen,a2,alen,p,k) != 0) fail("crypto_aead_decrypt with a=r overlap returns nonzero");
    if (memcmp(a2,r,rlen) != 0) fail("crypto_aead_decrypt does not handle a=r overlap");
    memcpy(a2,a,alen);
    if (crypto_aead_decrypt(t,&tlen,p2,c,clen,a,alen,p2,k) != 0) fail("crypto_aead_decrypt with p=r overlap returns nonzero");
    if (memcmp(p2,r,rlen) != 0) fail("crypto_aead_decrypt does not handle p=r overlap");
    memcpy(p2,p,plen);
    if (crypto_aead_decrypt(t,&tlen,k2,c,clen,a,alen,p,k2) != 0) fail("crypto_aead_decrypt with k=r overlap returns nonzero");
    if (memcmp(k2,r,rlen) != 0) fail("crypto_aead_decrypt does not handle k=r overlap");
    memcpy(k2,k,klen);
#endif
    
    c[myrandom() % clen] += 1 + (myrandom() % 255);
    if (crypto_aead_decrypt(t,&tlen,r,c,clen,a,alen,p,k) == 0)
      if ((tlen != mlen) || (memcmp(t,m,mlen) != 0) || (memcmp(r,s,slen) != 0))
        fail("crypto_aead_decrypt allows trivial forgeries");
    c[myrandom() % clen] += 1 + (myrandom() % 255);
    if (crypto_aead_decrypt(t,&tlen,r,c,clen,a,alen,p,k) == 0)
      if ((tlen != mlen) || (memcmp(t,m,mlen) != 0) || (memcmp(r,s,slen) != 0))
        fail("crypto_aead_decrypt allows trivial forgeries");
    c[myrandom() % clen] += 1 + (myrandom() % 255);
    if (crypto_aead_decrypt(t,&tlen,r,c,clen,a,alen,p,k) == 0)
      if ((tlen != mlen) || (memcmp(t,m,mlen) != 0) || (memcmp(r,s,slen) != 0))
        fail("crypto_aead_decrypt allows trivial forgeries");
  }
}
